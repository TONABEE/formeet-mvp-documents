## 実装指示書

### **1. デザイン実装の基本方針**

### **デザインシステムの適用**

```jsx
// デザイントークンの実装
const DesignSystem = {
  // カラーは変数化して一元管理
  colors: {
    // システムカラー（変更不可）
    system: {
      sleep: '#E8EAF6',
      appointment: '#4A90E2',
      travel: '#9E9E9E',  // 移動は必ずこの色
      routine: '#FFE5B4',
    },
    // プロジェクトカラー（ユーザー選択）
    projectPalette: [
      '#FF6B6B', '#FF9F40', '#FFD93D', '#6BCF7F', '#4ECDC4',
      '#4D96FF', '#9B59B6', '#FF6B9D', '#A67B5B', '#95A5A6'
    ]
  },

  // スペーシングは8の倍数
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
    xxl: 48
  },

  // アニメーション時間統一
  animation: {
    fast: 200,    // ms
    normal: 300,
    slow: 500
  }
};

```

### **2. 画面別実装指示**

## メイン画面（時間帯適応型）

### **実装の重要ポイント**

```tsx
interface MainScreenState {
  currentMode: 'normal' | 'morning_routine' | 'night_routine';
  currentTime: Date;
  userSettings: {
    wakeUpTime: string;  // "07:00"
    bedTime: string;     // "23:00"
  };
}

// モード判定ロジック（必須実装）
function determineMode(currentTime: Date, settings: UserSettings): ScreenMode {
  const now = currentTime.getHours() * 60 + currentTime.getMinutes();
  const wake = parseTime(settings.wakeUpTime);
  const bed = parseTime(settings.bedTime);

  // 朝ルーティンモード（起床1時間前〜1時間後）
  if (isInRange(now, wake - 60, wake + 60)) {
    return 'morning_routine';
  }

  // 夜ルーティンモード（就寝1時間前〜1時間後）
  if (isInRange(now, bed - 60, bed + 60)) {
    return 'night_routine';
  }

  return 'normal';
}

// 画面切替アニメーション
const screenTransition = {
  entering: { opacity: 0, transform: 'translateY(20px)' },
  entered: { opacity: 1, transform: 'translateY(0)' },
  duration: 300
};

```

### **ルーティンモードの特殊UI**

```jsx
// ルーティンタスクカード（特大サイズ）
const RoutineTaskCard = styled.TouchableOpacity`
  height: 80px;  /* 通常の2倍 */
  background: linear-gradient(135deg, #FFE5B4 0%, #FFF8E1 100%);
  border-radius: 12px;
  flex-direction: row;
  align-items: center;
  padding: 0 20px;
  margin-bottom: 12px;

  /* 押下時のフィードバック */
  &:active {
    opacity: 0.8;
    transform: scale(0.98);
  }
`;

// チェックボックスアニメーション
const CheckboxAnimation = {
  unchecked: { scale: 1, backgroundColor: '#FFF' },
  checked: {
    scale: [1, 1.2, 1],  // バウンス効果
    backgroundColor: '#7ED321',
    duration: 400
  }
};

```

## デイリープランニング画面

### **ドラッグ&ドロップ実装**

```jsx
// React Native Draggable使用
import Draggable from 'react-native-draggable';

const DailyPlanningScreen = () => {
  // ドラッグ中の視覚フィードバック
  const dragStyles = {
    dragging: {
      opacity: 0.7,
      transform: [{ scale: 1.05 }],
      shadowOpacity: 0.3,
      shadowRadius: 10
    },
    dropZoneActive: {
      backgroundColor: 'rgba(126, 211, 33, 0.1)',
      borderColor: '#7ED321',
      borderWidth: 2,
      borderStyle: 'dashed'
    }
  };

  // ドロップ時の自動スナップ
  const snapToGrid = (position) => {
    const gridSize = 15; // 15分単位
    return Math.round(position / gridSize) * gridSize;
  };

  // 配置可能判定
  const canDrop = (task, timeSlot) => {
    return !hasConflict(timeSlot) &&
           hasEnoughTime(task.duration, timeSlot) &&
           !isInFixedBlock(timeSlot); // 移動・予定ブロックは配置不可
  };
};

```

### **AI自動配置のビジュアル表現**

```jsx
// 配置アニメーション
const AutoPlacementAnimation = {
  // タスクが飛んでいくアニメーション
  taskFlyIn: {
    from: { translateX: -screenWidth, opacity: 0 },
    to: { translateX: 0, opacity: 1 },
    duration: 500,
    delay: (index) => index * 100, // 順番に飛んでくる
    easing: Easing.bezier(0.25, 0.1, 0.25, 1)
  },

  // 配置完了時のパルス効果
  placementComplete: {
    scale: [1, 1.05, 1],
    duration: 300
  }
};

```

## スケジュール管理画面

### **プロジェクト色の適用ルール**

```tsx
// タスクブロックのスタイル生成
function getTaskBlockStyle(task: Task, project: Project) {
  const baseColor = project.color;

  return {
    backgroundColor: `${baseColor}70`, // 70%透明度
    borderLeftWidth: 4,
    borderLeftColor: baseColor,

    // ホバー/プレス時
    pressed: {
      backgroundColor: `${baseColor}90`, // 90%透明度
    },

    // 実行中のタスク
    active: {
      backgroundColor: baseColor,
      shadowColor: baseColor,
      shadowOpacity: 0.4,
      shadowRadius: 8,
      // パルスアニメーション
      animation: 'pulse 2s infinite'
    }
  };
}

// 移動ブロックは常にグレー
const TravelBlockStyle = {
  backgroundColor: '#9E9E9E40', // 40%透明度の固定グレー
  borderStyle: 'dashed',
  borderWidth: 1,
  borderColor: '#9E9E9E',
  // プロジェクト色の影響を受けない
  immune: true
};

```

### **現在時刻ラインの実装**

```jsx
// 1分ごとに更新される赤いライン
const CurrentTimeLine = () => {
  const [position, setPosition] = useState(calculatePosition());

  useEffect(() => {
    const timer = setInterval(() => {
      setPosition(calculatePosition());
    }, 60000); // 1分ごと

    return () => clearInterval(timer);
  }, []);

  return (
    <View style={{
      position: 'absolute',
      top: position,
      left: 0,
      right: 0,
      height: 2,
      backgroundColor: '#FF5252',
      zIndex: 999,

      // 赤い丸（現在時刻インジケーター）
      &::before: {
        content: '',
        position: 'absolute',
        left: 0,
        top: -4,
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: '#FF5252'
      }
    }} />
  );
};

```

## タスク管理画面（Notionライク）

### **ビュー切替の実装**

```jsx
// ビューコンポーネントの動的切替
const TaskManagementScreen = () => {
  const [currentView, setCurrentView] = useState('table');

  const ViewComponents = {
    table: TableView,
    kanban: KanbanView,
    calendar: CalendarView,
    gantt: GanttView // Phase 2
  };

  const CurrentViewComponent = ViewComponents[currentView];

  // ビュー切替時のアニメーション
  const viewTransition = {
    exiting: { opacity: 0, translateX: -20 },
    entering: { opacity: 0, translateX: 20 },
    entered: { opacity: 1, translateX: 0 },
    duration: 300
  };

  return <CurrentViewComponent {...props} />;
};

```

### **フィルター機能の実装**

```tsx
// 複合フィルターロジック
interface FilterCriteria {
  date?: 'today' | 'this_week' | 'overdue';
  projects?: string[];  // 複数選択可能
  priority?: number[];   // [1, 2, 3]
  status?: TaskStatus[];
  hasSchedule?: boolean;
}

function applyFilters(tasks: Task[], criteria: FilterCriteria): Task[] {
  return tasks.filter(task => {
    // 日付フィルター
    if (criteria.date === 'today' && !isToday(task.scheduledDate)) {
      return false;
    }

    // プロジェクトフィルター（OR条件）
    if (criteria.projects?.length &&
        !criteria.projects.includes(task.projectId)) {
      return false;
    }

    // 優先度フィルター
    if (criteria.priority?.length &&
        !criteria.priority.includes(task.priority)) {
      return false;
    }

    return true;
  });
}

```

## 位置情報機能の実装

### **GPS追跡とバッテリー最適化**

```jsx
import BackgroundGeolocation from 'react-native-background-geolocation';

// 位置情報追跡の設定
const locationConfig = {
  // 通常時（低頻度）
  normal: {
    desiredAccuracy: BackgroundGeolocation.DESIRED_ACCURACY_LOW,
    distanceFilter: 100,     // 100m移動で更新
    stopOnTerminate: false,
    startOnBoot: true,
    interval: 60000,          // 1分ごと
    fastestInterval: 30000
  },

  // 移動予定前後（高精度）
  highAccuracy: {
    desiredAccuracy: BackgroundGeolocation.DESIRED_ACCURACY_HIGH,
    distanceFilter: 10,       // 10m移動で更新
    interval: 5000,           // 5秒ごと
    fastestInterval: 2000,

    // ジオフェンス（到着/出発検知）
    geofences: [
      {
        identifier: 'departure',
        radius: 100,
        notifyOnExit: true
      },
      {
        identifier: 'arrival',
        radius: 100,
        notifyOnEntry: true
      }
    ]
  }
};

// 移動検知ロジック
function detectMovement(location) {
  const speed = location.coords.speed;
  const accuracy = location.coords.accuracy;

  if (accuracy < 50) {  // 精度50m以内の場合のみ判定
    if (speed > 1) {    // 1m/s以上で移動中と判定
      return 'moving';
    } else {
      return 'stationary';
    }
  }

  return 'unknown';
}

```

### **移動時間の学習と予測改善**

```jsx
// 移動実績から予測精度を改善
class TravelTimePredictor {
  // 実績データの蓄積
  async recordActualTravel(travel: TravelRecord) {
    await db.travelLogs.insert({
      route: `${travel.origin}-${travel.destination}`,
      dayOfWeek: travel.date.getDay(),
      timeOfDay: travel.departureTime.getHours(),
      plannedDuration: travel.plannedDuration,
      actualDuration: travel.actualDuration,
      delay: travel.actualDuration - travel.plannedDuration
    });
  }

  // 予測精度の改善
  async getPredictedDuration(origin, destination, departureTime) {
    // 過去の同じルート・時間帯のデータを取得
    const historicalData = await db.travelLogs.find({
      route: `${origin}-${destination}`,
      dayOfWeek: departureTime.getDay(),
      timeOfDay: { $near: departureTime.getHours() }
    });

    if (historicalData.length > 5) {
      // 実績データが十分ある場合は平均遅延を加算
      const avgDelay = average(historicalData.map(d => d.delay));
      const googlePrediction = await getGoogleMapsTime(origin, destination);

      return {
        duration: googlePrediction + avgDelay,
        confidence: 'high',
        basedOn: 'historical'
      };
    }

    // データが少ない場合はGoogle Mapsの予測に余裕を持たせる
    return {
      duration: googlePrediction * 1.2,
      confidence: 'low',
      basedOn: 'google'
    };
  }
}

```

## インタラクション詳細

### **マイクロインタラクション実装**

```jsx
// Haptic Feedback（触覚フィードバック）
import { HapticFeedback } from 'react-native';

const interactions = {
  // タスク完了時
  taskComplete: () => {
    HapticFeedback.notification(
      HapticFeedback.NotificationTypes.Success
    );
    // チェックマークアニメーション
    Animated.sequence([
      Animated.spring(scale, { toValue: 1.3 }),
      Animated.spring(scale, { toValue: 1 })
    ]).start();
  },

  // ドラッグ開始時
  dragStart: () => {
    HapticFeedback.impact(
      HapticFeedback.ImpactStyles.Light
    );
  },

  // エラー時
  error: () => {
    HapticFeedback.notification(
      HapticFeedback.NotificationTypes.Error
    );
    // シェイクアニメーション
    Animated.sequence([
      Animated.timing(translateX, { toValue: 10, duration: 50 }),
      Animated.timing(translateX, { toValue: -10, duration: 50 }),
      Animated.timing(translateX, { toValue: 10, duration: 50 }),
      Animated.timing(translateX, { toValue: 0, duration: 50 })
    ]).start();
  }
};

```

### **状態遷移アニメーション**

```jsx
// Lottieアニメーション使用
import LottieView from 'lottie-react-native';

const StateAnimations = {
  // ルーティンモード切替
  routineModeTransition: require('./animations/sun-moon.json'),

  // タスク配置成功
  taskPlacementSuccess: require('./animations/check-success.json'),

  // 移動開始通知
  departureAlert: require('./animations/location-pulse.json'),

  // レベルアップ
  levelUp: require('./animations/confetti.json')
};

```

## エラーハンドリングとフォールバック

### **位置情報エラー時の対応**

```jsx
const LocationErrorHandling = {
  // GPS無効時
  locationServicesDisabled: () => {
    showAlert({
      title: '位置情報をONにしてください',
      message: '移動時間の自動計算には位置情報が必要です',
      actions: [
        { text: '設定を開く', onPress: openSettings },
        { text: '手動で入力', onPress: showManualInput }
      ]
    });
  },

  // 精度が低い時
  lowAccuracy: () => {
    showToast('GPS精度が低いため、予測時間を使用しています');
    // Google Maps APIにフォールバック
    return useGoogleMapsAPI();
  },

  // オフライン時
  offline: () => {
    // キャッシュされたデータを使用
    return getCachedTravelTime();
  }
};

```

## パフォーマンス最適化

### **リスト最適化**

```jsx
// FlatListの最適化設定
const optimizedListProps = {
  removeClippedSubviews: true,
  maxToRenderPerBatch: 10,
  initialNumToRender: 10,
  windowSize: 10,
  getItemLayout: (data, index) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index,
    index
  }),
  keyExtractor: (item) => item.id
};

```

### **画像・アセット最適化**

```jsx
// プロジェクトアイコンのキャッシュ
const IconCache = new Map();

function getProjectIcon(projectId) {
  if (IconCache.has(projectId)) {
    return IconCache.get(projectId);
  }

  const icon = loadIcon(projectId);
  IconCache.set(projectId, icon);
  return icon;
}

```

---